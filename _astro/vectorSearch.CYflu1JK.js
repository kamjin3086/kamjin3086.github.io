import{o as p}from"./index.CRO4pM4d.js";import"./pako.esm.CMINtMsn.js";class k{db=null;DB_NAME="memory-embeddings";DB_VERSION=1;initPromise=null;async initialize(){return this.initPromise?this.initPromise:(this.initPromise=(async()=>{try{console.log("ğŸ”„ [EmbeddingCache] Initializing IndexedDB..."),this.db=await p(this.DB_NAME,this.DB_VERSION,{upgrade(e){const t=e.createObjectStore("embeddings",{keyPath:"memoryId"});t.createIndex("byModelVersion","modelVersion"),t.createIndex("byGeneratedAt","generatedAt"),e.createObjectStore("metadata")},blocked(){console.warn("âš ï¸ [EmbeddingCache] Database upgrade blocked")},blocking(){console.warn("âš ï¸ [EmbeddingCache] Blocking upgrade")}}),console.log("âœ… [EmbeddingCache] IndexedDB initialized")}catch(e){throw console.error("âŒ [EmbeddingCache] Failed to initialize:",e),e}})(),this.initPromise)}async ensureInitialized(){this.db||await this.initialize()}async saveEmbedding(e,t,r){await this.ensureInitialized();try{const i={memoryId:e,embedding:t,modelVersion:r,generatedAt:Date.now()};await this.db.put("embeddings",i),console.log(`âœ… [EmbeddingCache] Saved: ${e}`)}catch(i){throw console.error(`âŒ [EmbeddingCache] Failed to save ${e}:`,i),i}}async batchSaveEmbeddings(e){await this.ensureInitialized();try{const t=this.db.transaction("embeddings","readwrite"),r=t.objectStore("embeddings");for(const i of e)await r.put({...i,generatedAt:Date.now()});await t.done,console.log(`âœ… [EmbeddingCache] Batch saved: ${e.length} items`)}catch(t){throw console.error("âŒ [EmbeddingCache] Batch save failed:",t),t}}async getEmbedding(e){await this.ensureInitialized();try{return(await this.db.get("embeddings",e))?.embedding||null}catch(t){return console.error(`âŒ [EmbeddingCache] Failed to get ${e}:`,t),null}}async batchGetEmbeddings(e){await this.ensureInitialized();const t=new Map;try{const i=this.db.transaction("embeddings","readonly").objectStore("embeddings"),o=e.map(async a=>{const c=await i.get(a);c&&t.set(a,c.embedding)});await Promise.all(o)}catch(r){console.error("âŒ [EmbeddingCache] Batch get failed:",r)}return t}async hasEmbedding(e){return await this.getEmbedding(e)!==null}async deleteEmbedding(e){await this.ensureInitialized();try{await this.db.delete("embeddings",e),console.log(`ğŸ—‘ï¸ [EmbeddingCache] Deleted: ${e}`)}catch(t){throw console.error(`âŒ [EmbeddingCache] Failed to delete ${e}:`,t),t}}async clearAll(){await this.ensureInitialized();try{await this.db.clear("embeddings"),console.log("ğŸ—‘ï¸ [EmbeddingCache] Cleared all embeddings")}catch(e){throw console.error("âŒ [EmbeddingCache] Failed to clear:",e),e}}async clearObsolete(e){await this.ensureInitialized();try{const t=this.db.transaction("embeddings","readwrite"),r=t.objectStore("embeddings"),o=await r.index("byModelVersion").getAllKeys(IDBKeyRange.lowerBound(e,!0));for(const c of o)await r.delete(c);await t.done;const a=o.length;return console.log(`ğŸ—‘ï¸ [EmbeddingCache] Cleared ${a} obsolete embeddings`),a}catch(t){return console.error("âŒ [EmbeddingCache] Failed to clear obsolete:",t),0}}async getStats(){await this.ensureInitialized();try{const e=await this.db.count("embeddings"),r=this.db.transaction("embeddings","readonly").objectStore("embeddings").index("byGeneratedAt"),i=await r.openCursor(null,"next"),o=await r.openCursor(null,"prev"),a=i?.value?.generatedAt||null,c=o?.value?.generatedAt||null;let g=null;return o?.value&&(g=o.value.modelVersion),{count:e,modelVersion:g,oldest:a,newest:c}}catch(e){return console.error("âŒ [EmbeddingCache] Failed to get stats:",e),{count:0,modelVersion:null,oldest:null,newest:null}}}async setMetadata(e,t){await this.ensureInitialized();try{await this.db.put("metadata",{key:e,value:t,updatedAt:Date.now()})}catch(r){console.error(`âŒ [EmbeddingCache] Failed to save metadata ${e}:`,r)}}async getMetadata(e){await this.ensureInitialized();try{return(await this.db.get("metadata",e))?.value||null}catch(t){return console.error(`âŒ [EmbeddingCache] Failed to get metadata ${e}:`,t),null}}async exportAll(){await this.ensureInitialized();try{const e=await this.db.getAll("embeddings");return console.log(`ğŸ“¦ [EmbeddingCache] Exported ${e.length} embeddings`),e}catch(e){return console.error("âŒ [EmbeddingCache] Export failed:",e),[]}}async importAll(e){await this.ensureInitialized();try{const t=this.db.transaction("embeddings","readwrite"),r=t.objectStore("embeddings");let i=0;for(const o of e)await r.put(o),i++;return await t.done,console.log(`ğŸ“¦ [EmbeddingCache] Imported ${i} embeddings`),i}catch(t){return console.error("âŒ [EmbeddingCache] Import failed:",t),0}}async close(){this.db&&(this.db.close(),this.db=null,this.initPromise=null,console.log("ğŸ”’ [EmbeddingCache] Database closed"))}}const d=new k;function S(n){return new Worker("/_astro/embedding-worker.worker-DXrsO4mI.js",{name:n?.name})}const w={version:"Xenova/bge-small-zh-v1.5",dimension:512};class M{worker=null;initPromise=null;messageId=0;pendingMessages=new Map;getWorker(){if(!this.worker)try{this.worker=new S,this.worker.addEventListener("message",this.handleMessage.bind(this)),this.worker.addEventListener("error",this.handleError.bind(this)),console.log("âœ… [WorkerManager] Worker created")}catch(e){throw console.error("âŒ [WorkerManager] Failed to create worker:",e),e}return this.worker}handleMessage(e){const{type:t,payload:r,id:i}=e.data,o=i!=null?this.pendingMessages.get(i):void 0;if(!o){t==="ERROR"?console.error("âŒ [WorkerManager] Worker reported error:",r?.error):console.warn(`[WorkerManager] No pending handler for message ${i}`);return}switch(t){case"PONG":o.resolve(void 0);break;case"INITIALIZED":o.resolve(void 0);break;case"EMBEDDING_READY":o.resolve(r.embedding);break;case"BATCH_READY":o.resolve(r.embeddings);break;case"DISPOSED":o.resolve(void 0);break;case"ERROR":o.reject(new Error(r.error));break;default:o.reject(new Error(`Unknown response type: ${t}`))}this.pendingMessages.delete(i)}handleError(e){const t={message:e.message,filename:e.filename,lineno:e.lineno,colno:e.colno};console.error("âŒ [WorkerManager] Worker error:",t);try{this.worker?.terminate()}catch{}this.worker=null,this.initPromise=null;for(const[r,i]of this.pendingMessages)i.reject(new Error(t.message||`Worker error${t.filename?` @ ${t.filename}:${t.lineno}:${t.colno}`:""}`));this.pendingMessages.clear()}sendMessage(e,t=3e4){return new Promise((r,i)=>{const o=++this.messageId,a=this.getWorker(),c=setTimeout(()=>{this.pendingMessages.delete(o),i(new Error(`Worker timeout after ${t}ms`))},t);this.pendingMessages.set(o,{resolve:g=>{clearTimeout(c),r(g)},reject:g=>{clearTimeout(c),i(g)}}),a.postMessage({...e,id:o})})}async initialize(){return this.initPromise?this.initPromise:(this.initPromise=(async()=>{console.log("ğŸ”„ [WorkerManager] Initializing worker..."),await this.sendMessage({type:"INITIALIZE"}),console.log("âœ… [WorkerManager] Worker initialized")})(),this.initPromise)}async ping(e=3e3){await this.sendMessage({type:"PING"},e)}reset(){this.terminate()}async generateEmbedding(e){return await this.initialize(),this.sendMessage({type:"GENERATE",payload:{text:e}})}async generateBatch(e){return await this.initialize(),e.length===0?[]:this.sendMessage({type:"GENERATE_BATCH",payload:{texts:e}})}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.initPromise=null,this.pendingMessages.clear(),console.log("ğŸ§¹ [WorkerManager] Worker terminated"))}}const l=new M;async function $(){try{return await l.ping(3e3),{status:"ready"}}catch(n){return{status:"error",error:n instanceof Error?n.message:String(n)}}}async function A(){try{return await l.initialize(),{status:"ready"}}catch(n){return{status:"error",error:n instanceof Error?n.message:String(n)}}}function x(){l.reset()}function V(n,e){if(n.length!==e.length)throw new Error("Vector dimensions must match");let t=0,r=0,i=0;for(let a=0;a<n.length;a++)t+=n[a]*e[a],r+=n[a]*n[a],i+=e[a]*e[a];const o=Math.sqrt(r)*Math.sqrt(i);return o===0?0:t/o}async function D(n,e,t={}){const{topK:r=10,minSimilarity:i=.5,useCache:o=!0}=t;if(!n.trim())return[];console.log(`ğŸ” [VectorSearch] Searching: "${n}" in ${e.length} memories`);try{const a=await l.generateEmbedding(n),c=e.map(s=>s.id),g=o?await d.batchGetEmbeddings(c):new Map,h=[],b=[];for(const s of e){let m=g.get(s.id);if(!m){b.push(s);continue}const u=V(a,m);u>=i&&h.push({memory:s,similarity:u,matchReason:"semantic"})}b.length>0&&C(b,w.version);const E=h.sort((s,m)=>m.similarity-s.similarity).slice(0,r);return console.log(`âœ… [VectorSearch] Found ${E.length} results (cached: ${h.length}, uncached: ${b.length})`),E}catch(a){throw console.error("âŒ [VectorSearch] Search failed:",a),a}}async function C(n,e){console.log(`ğŸ”„ [VectorSearch] Generating ${n.length} embeddings in background...`);for(const t of n)try{const r=await l.generateEmbedding(t.text);await d.saveEmbedding(t.id,r,e),console.log(`âœ… [VectorSearch] Generated: ${t.text.slice(0,30)}...`)}catch(r){console.error("âŒ [VectorSearch] Failed to generate embedding:",r)}console.log("âœ… [VectorSearch] Background generation complete")}async function B(n,e={}){const{modelVersion:t=w.version,onProgress:r,chunkSize:i=10,chunkDelay:o=50}=e;try{console.log(`ğŸš€ [VectorSearch] Starting migration: ${n.length} memories`),r?.("initializing",0),await d.initialize(),await l.initialize(),r?.("loading_model",10),r?.("checking_cache",20);const c=(await d.getStats()).count,g=n.length;if(console.log(`ğŸ“Š [VectorSearch] Cached: ${c}/${g}`),c>=g){console.log("âœ… [VectorSearch] All memories already cached"),r?.("complete",100);return}const h=[];for(const s of n)await d.hasEmbedding(s.id)||h.push(s);console.log(`ğŸ“Š [VectorSearch] Need to generate: ${h.length} embeddings`),r?.("generating_embeddings",30);const b=h.length;let E=0;for(let s=0;s<h.length;s+=i){const m=h.slice(s,s+i);for(const u of m){const y=await l.generateEmbedding(u.text);await d.saveEmbedding(u.id,y,t),E++;const f=30+E/b*70;r?.("generating_embeddings",f)}await new Promise(u=>setTimeout(u,o))}console.log("âœ… [VectorSearch] Migration complete"),r?.("complete",100)}catch(a){throw console.error("âŒ [VectorSearch] Migration failed:",a),r?.("error",0),a}}async function W(n){try{console.log("ğŸš€ [VectorSearch] Initializing..."),n?.("initializing",0),await d.initialize();const e=await d.getStats();return console.log(`ğŸ“¦ [VectorSearch] Cached embeddings: ${e.count}`),n?.("loading_model",50),await l.initialize(),console.log("âœ… [VectorSearch] Initialized"),n?.("complete",100),!0}catch(e){return console.error("âŒ [VectorSearch] Initialization failed:",e),n?.("error",0),!1}}function P(){l.terminate(),console.log("ğŸ§¹ [VectorSearch] Cleaned up")}async function I(n){try{const e=await l.generateEmbedding(n.text);await d.saveEmbedding(n.id,e,w.version),console.log(`âœ… [VectorSearch] Generated embedding for: ${n.text.slice(0,30)}...`)}catch(e){throw console.error("âŒ [VectorSearch] Failed to generate embedding:",e),e}}async function F(n){try{for(const e of n)await I(e)}catch(e){throw console.error("âŒ [VectorSearch] Batch generation failed:",e),e}}async function R(n,e){try{await d.deleteEmbedding(n);const t=await l.generateEmbedding(e);await d.saveEmbedding(n,t,w.version),console.log(`âœ… [VectorSearch] Updated embedding for: ${n}`)}catch(t){throw console.error("âŒ [VectorSearch] Failed to update embedding:",t),t}}async function G(n){try{await d.deleteEmbedding(n),console.log(`ğŸ—‘ï¸ [VectorSearch] Deleted embedding for: ${n}`)}catch(e){throw console.error("âŒ [VectorSearch] Failed to delete embedding:",e),e}}async function N(){return{...await d.getStats(),modelVersion:w.version,dimension:w.dimension,workerInitialized:l.initPromise!==null}}export{w as MODEL_CONFIG,F as batchGenerateMemoryEmbeddings,$ as checkVectorEngine,P as cleanupVectorSearch,V as cosineSimilarity,G as deleteMemoryEmbedding,I as generateMemoryEmbedding,N as getVectorSearchStats,W as initializeVectorSearch,B as migrateAllMemories,x as resetVectorEngine,D as searchMemoriesVector,R as updateMemoryEmbedding,A as warmupVectorEngine};
